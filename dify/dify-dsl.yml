app:
  name: CodeTale - Git Repo Analyzer
  description: Analyzes a GitHub repo and generates structured presentation content
  mode: workflow
  icon: ""
  icon_background: "#F1F5F9"
  use_icon_as_answer_icon: false

dependencies: []

kind: app
version: "0.5.0"

workflow:
  conversation_variables: []
  environment_variables:
    - name: GITHUB_TOKEN
      value: ""
      value_type: secret

  features:
    file_upload:
      enabled: false
      allowed_file_extensions: []
      allowed_file_types: []
      allowed_file_upload_methods: []
      fileUploadConfig:
        audio_file_size_limit: 0
        batch_count_limit: 0
        file_size_limit: 0
        image_file_size_limit: 0
        video_file_size_limit: 0
        workflow_file_upload_limit: 0
      image:
        enabled: false
        number_limits: 0
        transfer_methods: []
      number_limits: 0
    opening_statement: ""
    retriever_resource:
      enabled: false
    sensitive_word_avoidance:
      enabled: false
    speech_to_text:
      enabled: false
    suggested_questions: []
    suggested_questions_after_answer:
      enabled: false
    text_to_speech:
      enabled: false
      language: ""
      voice: ""

  graph:
    edges:
      - id: "start_to_parse"
        source: "start_node"
        sourceHandle: "source"
        target: "parse_url_node"
        targetHandle: "target"
        type: "custom"
        data:
          isInIteration: false
          isInLoop: false
          sourceType: start
          targetType: code

      - id: "parse_to_tree"
        source: "parse_url_node"
        sourceHandle: "source"
        target: "fetch_tree_node"
        targetHandle: "target"
        type: "custom"
        data:
          isInIteration: false
          isInLoop: false
          sourceType: code
          targetType: code

      - id: "tree_to_key"
        source: "fetch_tree_node"
        sourceHandle: "source"
        target: "fetch_key_node"
        targetHandle: "target"
        type: "custom"
        data:
          isInIteration: false
          isInLoop: false
          sourceType: code
          targetType: code

      - id: "key_to_deepwiki"
        source: "fetch_key_node"
        sourceHandle: "source"
        target: "deepwiki_node"
        targetHandle: "target"
        type: "custom"
        data:
          isInIteration: false
          isInLoop: false
          sourceType: code
          targetType: code

      - id: "deepwiki_to_analyst"
        source: "deepwiki_node"
        sourceHandle: "source"
        target: "analyst_node"
        targetHandle: "target"
        type: "custom"
        data:
          isInIteration: false
          isInLoop: false
          sourceType: code
          targetType: llm

      - id: "analyst_to_writer"
        source: "analyst_node"
        sourceHandle: "source"
        target: "writer_node"
        targetHandle: "target"
        type: "custom"
        data:
          isInIteration: false
          isInLoop: false
          sourceType: llm
          targetType: llm

      - id: "writer_to_validator"
        source: "writer_node"
        sourceHandle: "source"
        target: "validator_node"
        targetHandle: "target"
        type: "custom"
        data:
          isInIteration: false
          isInLoop: false
          sourceType: llm
          targetType: llm

      - id: "validator_to_end"
        source: "validator_node"
        sourceHandle: "source"
        target: "end_node"
        targetHandle: "target"
        type: "custom"
        data:
          isInIteration: false
          isInLoop: false
          sourceType: llm
          targetType: end

    nodes:
      - id: "start_node"
        type: "custom"
        position:
          x: 0
          y: 0
        positionAbsolute:
          x: 0
          y: 0
        width: 260
        height: 110
        sourcePosition: right
        targetPosition: left
        selected: false
        data:
          title: Start
          desc: Input GitHub repository URL.
          type: start
          variables:
            - label: GitHub Repo URL
              variable: repo_url
              type: text-input
              required: true
              max_length: 300
              options: []
              placeholder: https://github.com/vercel/next.js
              hint: ""
              default: ""
          x-outputs:
            - name: repo_url
              type: string

      - id: "parse_url_node"
        type: "custom"
        position:
          x: 320
          y: 0
        positionAbsolute:
          x: 320
          y: 0
        width: 300
        height: 150
        sourcePosition: right
        targetPosition: left
        selected: false
        data:
          title: "Parse URL"
          desc: Extract owner and repo from URL.
          type: code
          code_language: python3
          code: |
            import re

            def parse_repo_url(raw: str):
                raw = (raw or "").strip().strip("<>\"'")
                if not raw:
                    raise ValueError("Invalid GitHub URL")

                if raw.startswith("git@github.com:"):
                    raw = "https://github.com/" + raw.split("git@github.com:", 1)[1]
                if raw.startswith("ssh://git@github.com/"):
                    raw = "https://github.com/" + raw.split("ssh://git@github.com/", 1)[1]

                if "github.com" in raw:
                    m = re.search(r"github\.com[:/]+([^/]+)/([^/#?]+)", raw)
                    if not m:
                        raise ValueError("Invalid GitHub URL")
                    owner, repo = m.group(1), m.group(2)
                elif "/" in raw:
                    owner, repo = raw.split("/", 1)
                else:
                    raise ValueError("Invalid GitHub URL")

                repo = repo.replace(".git", "").strip()
                if not owner or not repo:
                    raise ValueError("Invalid GitHub URL")
                return owner, repo

            def main(repo_url: str) -> dict:
                owner, repo = parse_repo_url(repo_url)
                return {
                    "owner": owner,
                    "repo": repo
                }
          variables:
            - variable: repo_url
              value_selector:
                - start_node
                - repo_url
          outputs:
            owner:
              type: string
              children: null
            repo:
              type: string
              children: null
          x-outputs:
            - name: owner
              type: string
            - name: repo
              type: string

      - id: "fetch_tree_node"
        type: "custom"
        position:
          x: 650
          y: 0
        positionAbsolute:
          x: 650
          y: 0
        width: 320
        height: 170
        sourcePosition: right
        targetPosition: left
        selected: false
        data:
          title: "Fetch Repo Tree"
          desc: Fetch metadata, tree, and README.
          type: code
          code_language: python3
          code: |
            import json
            import urllib.request
            import urllib.error

            API_ROOT = "https://api.github.com"
            REQUEST_TIMEOUT = 30
            USER_AGENT = "CodeTale"

            def api_get(url, token=None):
                headers = {
                    "Accept": "application/vnd.github.v3+json",
                    "User-Agent": USER_AGENT
                }
                if token:
                    headers["Authorization"] = f"Bearer {token}"
                req = urllib.request.Request(url, headers=headers)
                try:
                    with urllib.request.urlopen(req, timeout=REQUEST_TIMEOUT) as resp:
                        return resp.status, resp.read()
                except urllib.error.HTTPError as e:
                    return e.code, e.read()
                except Exception as e:
                    raise RuntimeError(f"HTTP error: {e}")

            def truncate_tree(paths):
                if len(paths) <= 500:
                    return paths
                keep = []
                top = [p for p in paths if p.count("/") == 0]
                key_dirs = [p for p in paths if p.startswith("src/") or p.startswith("app/") or p.startswith("lib/")]
                keep.extend(top)
                keep.extend(key_dirs[:200])
                for p in paths:
                    if p not in keep:
                        keep.append(p)
                    if len(keep) >= 500:
                        break
                return keep

            def main(owner: str, repo: str, github_token: str = "") -> dict:
                token = github_token.strip() if github_token else None

                status, data = api_get(f"{API_ROOT}/repos/{owner}/{repo}", token)
                if status != 200:
                    raise RuntimeError(f"Repo fetch failed: {status}")
                info = json.loads(data.decode("utf-8"))
                default_branch = info.get("default_branch", "main")

                status, data = api_get(f"{API_ROOT}/repos/{owner}/{repo}/git/trees/{default_branch}?recursive=1", token)
                if status != 200:
                    raise RuntimeError(f"Tree fetch failed: {status}")
                tree = json.loads(data.decode("utf-8")).get("tree", [])
                paths = [t.get("path") for t in tree if t.get("type") == "blob" and t.get("path")]
                paths = truncate_tree(paths)

                # README (try raw content)
                readme_text = ""
                status, data = api_get(f"{API_ROOT}/repos/{owner}/{repo}/readme", token)
                if status == 200:
                    try:
                        payload = json.loads(data.decode("utf-8"))
                        download_url = payload.get("download_url")
                        if download_url:
                            status2, data2 = api_get(download_url, token=None)
                            if status2 == 200:
                                readme_text = data2.decode("utf-8", errors="replace")[:3000]
                    except Exception:
                        readme_text = ""

                metadata = {
                    "name": info.get("name", ""),
                    "description": info.get("description") or "",
                    "language": info.get("language") or "",
                    "stars": info.get("stargazers_count", 0),
                    "topics": info.get("topics") or [],
                    "default_branch": default_branch
                }

                return {
                    "metadata_json": json.dumps(metadata, ensure_ascii=False),
                    "tree_json": json.dumps(paths, ensure_ascii=False),
                    "readme": readme_text
                }
          variables:
            - variable: owner
              value_selector:
                - parse_url_node
                - owner
            - variable: repo
              value_selector:
                - parse_url_node
                - repo
            - variable: github_token
              value_selector:
                - env
                - GITHUB_TOKEN
          outputs:
            metadata_json:
              type: string
              children: null
            tree_json:
              type: string
              children: null
            readme:
              type: string
              children: null
          x-outputs:
            - name: metadata_json
              type: string
            - name: tree_json
              type: string
            - name: readme
              type: string

      - id: "fetch_key_node"
        type: "custom"
        position:
          x: 1000
          y: 0
        positionAbsolute:
          x: 1000
          y: 0
        width: 320
        height: 170
        sourcePosition: right
        targetPosition: left
        selected: false
        data:
          title: "Fetch Key Files"
          desc: Select and fetch key files.
          type: code
          code_language: python3
          code: |
            import json
            import urllib.request
            import urllib.error

            API_ROOT = "https://api.github.com"
            REQUEST_TIMEOUT = 30
            USER_AGENT = "CodeTale"

            def api_get(url, token=None):
                headers = {
                    "Accept": "application/vnd.github.v3+json",
                    "User-Agent": USER_AGENT
                }
                if token:
                    headers["Authorization"] = f"Bearer {token}"
                req = urllib.request.Request(url, headers=headers)
                try:
                    with urllib.request.urlopen(req, timeout=REQUEST_TIMEOUT) as resp:
                        return resp.status, resp.read()
                except urllib.error.HTTPError as e:
                    return e.code, e.read()
                except Exception as e:
                    raise RuntimeError(f"HTTP error: {e}")

            def pick_key_files(paths):
                picked = []
                def add(p):
                    if p not in picked:
                        picked.append(p)

                pset = set(paths)

                # Priority 1
                for name in ["package.json", "Cargo.toml", "pyproject.toml", "go.mod"]:
                    if name in pset:
                        add(name)

                # Priority 2
                for name in ["docker-compose.yml", "Dockerfile"]:
                    if name in pset:
                        add(name)
                for p in paths:
                    if p.startswith(".github/workflows/") and p.endswith(".yml"):
                        add(p)

                # Priority 3
                for p in paths:
                    lp = p.lower()
                    if lp.startswith("src/") and ("/main." in lp or "/index." in lp):
                        add(p)
                    if lp.startswith("src/lib.") or lp.startswith("app."):
                        add(p)

                # Priority 4
                for p in paths:
                    lp = p.lower()
                    if "config" in lp or "schema" in lp or "model" in lp:
                        add(p)

                return picked[:8]

            def fetch_raw(owner, repo, path, token=None):
                url = f"{API_ROOT}/repos/{owner}/{repo}/contents/{path}"
                status, data = api_get(url, token)
                if status != 200:
                    return ""
                try:
                    payload = json.loads(data.decode("utf-8"))
                    download_url = payload.get("download_url")
                    if download_url:
                        status2, data2 = api_get(download_url, token=None)
                        if status2 == 200:
                            return data2.decode("utf-8", errors="replace")[:2000]
                except Exception:
                    return ""
                return ""

            def main(tree_json: str, owner: str, repo: str, github_token: str = "") -> dict:
                token = github_token.strip() if github_token else None
                try:
                    paths = json.loads(tree_json)
                except Exception:
                    paths = []

                selected = pick_key_files(paths)
                key_files = []
                for p in selected:
                    content = fetch_raw(owner, repo, p, token)
                    key_files.append({"path": p, "content": content})

                return {"key_files_json": json.dumps(key_files, ensure_ascii=False)}
          variables:
            - variable: tree_json
              value_selector:
                - fetch_tree_node
                - tree_json
            - variable: owner
              value_selector:
                - parse_url_node
                - owner
            - variable: repo
              value_selector:
                - parse_url_node
                - repo
            - variable: github_token
              value_selector:
                - env
                - GITHUB_TOKEN
          outputs:
            key_files_json:
              type: string
              children: null
          x-outputs:
            - name: key_files_json
              type: string

      - id: "deepwiki_node"
        type: "custom"
        position:
          x: 1350
          y: 0
        positionAbsolute:
          x: 1350
          y: 0
        width: 320
        height: 170
        sourcePosition: right
        targetPosition: left
        selected: false
        data:
          title: "DeepWiki Enrichment"
          desc: Fetch summary from DeepWiki with graceful fallback.
          type: code
          code_language: python3
          code: |
            import json
            import urllib.request
            import urllib.error

            REQUEST_TIMEOUT = 20

            def api_get(url):
                req = urllib.request.Request(url, headers={"Accept": "application/json"})
                try:
                    with urllib.request.urlopen(req, timeout=REQUEST_TIMEOUT) as resp:
                        return resp.status, resp.read()
                except urllib.error.HTTPError as e:
                    return e.code, e.read()
                except Exception:
                    return 0, b""

            def main(owner: str, repo: str) -> dict:
                url = f"https://deepwiki.com/api/wiki/{owner}/{repo}/summary"
                status, data = api_get(url)
                if status != 200:
                    return {"deepwiki": None}
                try:
                    payload = json.loads(data.decode("utf-8"))
                    summary = payload.get("summary") or payload.get("text") or ""
                    if not summary:
                        return {"deepwiki": None}
                    return {"deepwiki": summary}
                except Exception:
                    return {"deepwiki": None}
          variables:
            - variable: owner
              value_selector:
                - parse_url_node
                - owner
            - variable: repo
              value_selector:
                - parse_url_node
                - repo
          outputs:
            deepwiki:
              type: string
              children: null
          x-outputs:
            - name: deepwiki
              type: string

      - id: "analyst_node"
        type: "custom"
        position:
          x: 1700
          y: 0
        positionAbsolute:
          x: 1700
          y: 0
        width: 320
        height: 200
        sourcePosition: right
        targetPosition: left
        selected: false
        data:
          type: llm
          title: "Agent 1: Code Analyst"
          desc: Structured analysis of repo.
          model:
            provider: "langgenius/openai/openai"
            name: gpt-4o
            mode: chat
            completion_params:
              temperature: 0.3
          prompt_template:
            - id: system
              role: system
              text: |-
                You are a senior software architect. Analyze the following GitHub repository data and produce a structured analysis.

                INPUT:
                - Repo metadata (name, description, language, stars, topics)
                - File tree
                - README excerpt
                - Key file contents
                - DeepWiki summary (may be null)

                OUTPUT a JSON object with:
                {
                  "project_name": "...",
                  "tagline": "one-line description",
                  "primary_language": "...",
                  "tech_stack": ["list", "of", "technologies"],
                  "architecture_type": "monolith|microservices|library|cli|fullstack|other",
                  "key_components": [
                    { "name": "...", "purpose": "...", "files": ["..."] }
                  ],
                  "data_flow": "description of how data flows through the system",
                  "design_patterns": ["list", "of", "patterns detected"],
                  "complexity_score": 1-10,
                  "notable_features": ["...", "..."],
                  "suggested_diagrams": [
                    { "type": "architecture|sequence|flow|class|er", "description": "what it should show" }
                  ]
                }

                Be precise. Only include what you can confirm from the code.
            - id: user
              role: user
              text: |-
                Repo metadata JSON:
                {{#fetch_tree_node.metadata_json#}}

                File tree JSON:
                {{#fetch_tree_node.tree_json#}}

                README excerpt:
                {{#fetch_tree_node.readme#}}

                Key files JSON:
                {{#fetch_key_node.key_files_json#}}

                DeepWiki summary:
                {{#deepwiki_node.deepwiki#}}
          context:
            enabled: false
            variable_selector: []
          variables: []
          vision:
            enabled: false
          x-outputs:
            - name: text
              type: string
          x-io-contracts:
            fixed_outputs:
              - name: text
                type: string

      - id: "writer_node"
        type: "custom"
        position:
          x: 2050
          y: 0
        positionAbsolute:
          x: 2050
          y: 0
        width: 320
        height: 200
        sourcePosition: right
        targetPosition: left
        selected: false
        data:
          type: llm
          title: "Agent 2: Presentation Script Writer"
          desc: Create presentation JSON.
          model:
            provider: "langgenius/openai/openai"
            name: gpt-4o
            mode: chat
            completion_params:
              temperature: 0.7
          prompt_template:
            - id: system
              role: system
              text: |-
                You are a world-class tech conference speaker and storytelling expert.
                Transform the code analysis into a compelling presentation script.

                INPUT: The code analysis JSON from the previous step.

                OUTPUT a JSON object:
                {
                  "title": "...",
                  "subtitle": "...",
                  "total_slides": N,
                  "estimated_duration_minutes": N,
                  "narrative_arc": "hook → context → deep-dive → wow-moment → takeaway",
                  "slides": [
                    {
                      "slide_number": 1,
                      "slide_type": "title|intro|architecture|code|diagram|comparison|quote|takeaway|outro",
                      "title": "...",
                      "speaker_notes": "what to say (2-3 sentences)",
                      "content": {
                        "bullets": ["...", "..."],
                        "code_snippet": { "language": "...", "code": "..." },
                        "diagram": { "type": "mermaid|flowchart|sequence", "spec": "..." },
                        "image_prompt": "description for AI image generation if needed",
                        "visual_suggestion": "what visual/animation to show"
                      },
                      "transition": "fade|slide|zoom|none",
                      "mood": "inspiring|technical|humorous|dramatic"
                    }
                  ]
                }

                RULES:
                - Generate 8-15 slides
                - Start with a HOOK (surprising fact or question about the project)
                - Include at least 1 architecture diagram (Mermaid syntax)
                - Include at least 1 code snippet from the actual repo
                - Include at least 1 "wow moment" slide
                - End with actionable takeaways
                - Speaker notes should be natural, conversational
                - Vary slide types — never 3 bullet slides in a row
            - id: user
              role: user
              text: |-
                {{#analyst_node.text#}}
          context:
            enabled: false
            variable_selector: []
          variables: []
          vision:
            enabled: false
          x-outputs:
            - name: text
              type: string
          x-io-contracts:
            fixed_outputs:
              - name: text
                type: string

      - id: "validator_node"
        type: "custom"
        position:
          x: 2400
          y: 0
        positionAbsolute:
          x: 2400
          y: 0
        width: 320
        height: 200
        sourcePosition: right
        targetPosition: left
        selected: false
        data:
          type: llm
          title: "Agent 3: Quality Validator"
          desc: Validate and fix presentation JSON.
          model:
            provider: "langgenius/openai/openai"
            name: gpt-4o
            mode: chat
            completion_params:
              temperature: 0.2
          prompt_template:
            - id: system
              role: system
              text: |-
                You are a QA editor for technical presentations.

                Validate the presentation JSON and fix any issues.

                CHECK:
                1. All Mermaid diagram specs are syntactically valid
                2. No slide has more than 5 bullets
                3. Code snippets have correct language tags
                4. Speaker notes are present for every slide
                5. slide_number is sequential
                6. JSON is valid and complete
                7. At least 1 diagram slide exists
                8. At least 1 code slide exists
                9. Total slides between 8 and 15
                10. No placeholder text like "TODO" or "..."

                If issues found: fix them and output the corrected JSON.
                If no issues: output the JSON unchanged.

                OUTPUT: the final validated presentation JSON (same schema as input).
                Add a top-level field: "validation": { "passed": true/false, "fixes_applied": ["..."] }
            - id: user
              role: user
              text: |-
                {{#writer_node.text#}}
          context:
            enabled: false
            variable_selector: []
          variables: []
          vision:
            enabled: false
          x-outputs:
            - name: text
              type: string
          x-io-contracts:
            fixed_outputs:
              - name: text
                type: string

      - id: "end_node"
        type: "custom"
        position:
          x: 2750
          y: 0
        positionAbsolute:
          x: 2750
          y: 0
        width: 260
        height: 110
        sourcePosition: right
        targetPosition: left
        selected: false
        data:
          title: Output
          desc: Return final JSON.
          type: end
          outputs:
            - variable: final_json
              value_selector:
                - validator_node
                - text
              value_type: string
          x-outputs:
            - name: final_json
              type: string

    viewport:
      x: 0
      y: 0
      zoom: 1

  rag_pipeline_variables: []
