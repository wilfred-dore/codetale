import type { RepoAnalysis } from "@/types/analysis";

/**
 * Convert a RepoAnalysis object to a well-structured Markdown document.
 * Designed for storage in git repos alongside the analyzed project.
 */
export function analysisToMarkdown(analysis: RepoAnalysis): string {
  const lines: string[] = [];
  const { _meta } = analysis;

  // Title & summary
  lines.push(`# üìä ${analysis.project_name} ‚Äî Analysis Report`);
  lines.push("");
  lines.push(`> Generated by **CodeTale** on ${new Date(_meta.analyzed_at).toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" })}`);
  lines.push(`> Source: \`${_meta.owner}/${_meta.repo}\` ¬∑ ${_meta.files_scanned}/${_meta.total_files} files analyzed`);
  if (_meta.sampling) {
    lines.push(`> Sampling: ${_meta.sampling.strategy.replace(/_/g, " ")} ¬∑ ~${(_meta.sampling.estimated_tokens / 1000).toFixed(1)}k tokens`);
  }
  lines.push("");
  lines.push("---");
  lines.push("");

  // Summary
  lines.push("## Summary");
  lines.push("");
  lines.push(analysis.summary);
  lines.push("");

  // Quick facts
  lines.push("## Quick Facts");
  lines.push("");
  lines.push(`| Attribute | Value |`);
  lines.push(`|-----------|-------|`);
  lines.push(`| **Main Language** | ${analysis.main_language} |`);
  lines.push(`| **Languages** | ${analysis.languages.join(", ")} |`);
  lines.push(`| **Framework** | ${analysis.framework || "N/A"} |`);
  lines.push(`| **Architecture** | ${analysis.architecture_type} |`);
  lines.push(`| **Complexity** | ${analysis.complexity_score}/10 |`);
  lines.push("");

  // Architecture diagram
  if (analysis.mermaid_architecture) {
    lines.push("## üèóÔ∏è Architecture Diagram");
    lines.push("");
    lines.push("```mermaid");
    lines.push(analysis.mermaid_architecture.trim());
    lines.push("```");
    lines.push("");
  }

  // Key components
  if (analysis.key_components.length > 0) {
    lines.push("## üß© Key Components");
    lines.push("");
    for (const comp of analysis.key_components) {
      lines.push(`### ${comp.name}`);
      lines.push("");
      lines.push(comp.purpose);
      lines.push("");
      if (comp.files.length > 0) {
        lines.push("**Files:**");
        for (const f of comp.files) {
          lines.push(`- \`${f}\``);
        }
        lines.push("");
      }
    }
  }

  // Design patterns
  if (analysis.patterns_detected.length > 0) {
    lines.push("## üîÑ Design Patterns");
    lines.push("");
    for (const p of analysis.patterns_detected) {
      lines.push(`- ${p}`);
    }
    lines.push("");
  }

  // Dependencies
  if (analysis.dependencies_highlight.length > 0) {
    lines.push("## ‚ö° Key Dependencies");
    lines.push("");
    lines.push(`| Package | Why |`);
    lines.push(`|---------|-----|`);
    for (const dep of analysis.dependencies_highlight) {
      lines.push(`| \`${dep.name}\` | ${dep.why} |`);
    }
    lines.push("");
  }

  // Interesting facts
  if (analysis.interesting_facts.length > 0) {
    lines.push("## üí° Interesting Facts");
    lines.push("");
    for (const fact of analysis.interesting_facts) {
      lines.push(`- ${fact}`);
    }
    lines.push("");
  }

  // Target audiences
  if (analysis.target_audiences) {
    lines.push("## üë• Target Audiences");
    lines.push("");
    const roles = ["developer", "manager", "investor"] as const;
    for (const role of roles) {
      if (analysis.target_audiences[role]) {
        lines.push(`### ${role.charAt(0).toUpperCase() + role.slice(1)}`);
        lines.push("");
        lines.push(analysis.target_audiences[role]);
        lines.push("");
      }
    }
  }

  // Narrative suggestion
  if (analysis.suggested_narrative) {
    const narr = analysis.suggested_narrative;
    lines.push("## üé¨ Suggested Narrative");
    lines.push("");
    lines.push(`**Hook:** ${narr.hook}`);
    lines.push("");
    if (narr.chapters.length > 0) {
      for (const ch of narr.chapters) {
        lines.push(`### ${ch.title}`);
        lines.push("");
        lines.push(ch.content);
        lines.push(`*~${ch.duration_seconds}s*`);
        lines.push("");
      }
    }
    lines.push(`**Closing:** ${narr.closing}`);
    lines.push("");
  }

  // Repo images
  if (analysis.repo_images && analysis.repo_images.length > 0) {
    lines.push("## üñºÔ∏è Repository Images");
    lines.push("");
    for (const img of analysis.repo_images) {
      const label = img.alt || img.path.split("/").pop() || "image";
      const techTag = img.likely_technical ? " *(technical)* " : " ";
      lines.push(`- ![${label}](${img.url})${techTag}‚Äî \`${img.path}\` (${img.source})`);
    }
    lines.push("");
  }

  lines.push("---");
  lines.push("*Generated by [CodeTale](https://codetale.dev)*");

  return lines.join("\n");
}

/** Trigger a markdown file download in the browser */
export function downloadAnalysisMarkdown(analysis: RepoAnalysis) {
  const md = analysisToMarkdown(analysis);
  const blob = new Blob([md], { type: "text/markdown;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `${analysis._meta.owner}-${analysis._meta.repo}-analysis.md`;
  a.click();
  URL.revokeObjectURL(url);
}
